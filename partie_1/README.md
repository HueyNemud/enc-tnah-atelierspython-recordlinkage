# S√©ance 1 : cr√©er un script Python de couplage d'enregistrements

Bonjour üëã !

Bienvenue dans la premi√®re partie de la s√©quence d√©di√©e au d√©veloppement d'une **interface en ligne de commande** de  **couplage d'enregistrements** de fichiers de donn√©es textuelles organis√©es en tables.

## Objectifs de la s√©ance üéØ

- d√©couvrir le couplage d'enregistrements pas √† pas ;
- se familiariser avec la manipulation de cha√Ænes de caract√®res en Python ;
- d√©couvrir & exp√©rimenter une m√©trique usuelle de comparaison de cha√Ænes de caract√®res : la [distance de Levenstein](https://www.geeksforgeeks.org/introduction-to-levenshtein-distance/) ;
- cr√©er et impl√©menter un algorithme de couplage d'enregistrements ;
- adapter l'algorithme √† des donn√©es "r√©elles" imparfaites produites par un v√©ritable projet d'humanit√©s num√©riques.

> [!IMPORTANT]
>
> 1. R√©pondre aux questions de code en coml√©tant le fichier de fichier de script Python `couplage.py`.
> 2. üÜò Une question n'est pas claire ? Vous √™tes bloqu√©(e) ?  N'attendez pas, **appelez √† l'aide üôã**. Le fichier `couplage.py` contient aussi des astuces et aides compl√©mentaires.  
> 3. ü§ñ Vous pouvez utiliser ChatGPT/Gemini/etc. pour vous aider, **mais** contraignez vous √† n'utiliser ses propositions **que si vous les comprenez vraiment**. Ne devenez pas esclave de la machine ! üôè
> 4. üò± Certaines sections contiennent des formules math√©matiques mais **pas de panique** : (1) elles sont plus faciles √† impl√©menter qu'elles n'en ont l'air et (2) vous serez aid√©(e) pas √† pas. Si quelque chose n'est pas clair, voir les points 2 & 3.
> 5. üòå Si vous n'avez pas r√©ussi ou pas eu le temps de r√©pondre √† une question, **pas de panique**, le r√©pertoire `correction/` contient une solution !

> [!TIP]
>
> La difficult√© d'une question **üß©**  est indiqu√©e de ‚≠ê √† ‚≠ê‚≠ê‚≠ê‚≠ê.

## A/ Introduction au couplage d'enregistrements (*Record Linkage*)

### Dans un monde parfait... üåàü¶Ñ

Lorsque l'on travaille avec des donn√©es num√©riques, il arrive souvent que l'on ait besoin de **combiner** deux ensembles de donn√©es qui contiennent des informations sur les m√™mes [entit√©s](https://www.dremio.com/wiki/entity/).
Dans un monde parfait, les entit√©s poss√®dent un **identifiant** unique, stable et non ambigu.
Pour combiner les deux tables il suffit donc de faire correspondre les enregistrements qui poss√®dent le m√™me **identifiant**.
Dans le vocabulaire des bases de donn√©es, on apelle cette op√©ration une **jointure**.

Voici par exemple deux extraits de catalogues stellaires contenant les **enregistrements** des √©toiles les plus proches du soleil :

| Gliese id | Nom               | Distance_al | Type        |
| --------- | ----------------- | ----------- | ----------- |
| GJ 559 A  | Alpha Centauri  A | 4.37        | Naine jaune |
| GJ 699    | √âtoile de Barnard | 5.963       | Naine rouge |

| Gliese id | Masse _M  | √Çge_Ga | Rayon_R   |
| --------- | --------- | ------ | --------- |
| GJ 406    | 0.09-0.13 | 10     | 0.16-0.19 |
| GJ 699    | 0.162     | 10     | 0.187     |

Comme deux catalogues indexent les √©toiles avec leur identifiant unique [Gliese](https://fr.wikipedia.org/wiki/Catalogue_Gliese), les combiner est trivial : il suffit de coupler les enregistrements avec le m√™me `Gliese_id`. Facile, non ? üòé

### La dure r√©alit√© üò•

√âvidemment, ce n'est souvent pas aussi simple.
Les probl√®mes commencent lorsque les enregistrements n'ont pas d'identifiant unique clair, que les informations sont incompl√®tes, bruit√©es, erron√©es, bref le genre de situation typique des donn√©es en humanit√©s num√©riques, produites par des processus de traitement ou extraction plus ou moins automatiques !

Voici deux extraits de donn√©es issues de sources historiques imprim√©es, les √©ditions de 1855 et 1856 de ["l'Annuaire g√©n√©ral du commerce et de l'industrie de la ville de Bordeaux [...]"](https://gallica.bnf.fr/services/engine/search/sru?operation=searchRetrieve&version=1.2&collapsing=disabled&query=%28gallica%20all%20%22Annuaire%20g%C3%A9n%C3%A9ral%20du%20commerce%20et%20de%20l%27industrie%20de%20la%20ville%20de%20Bordeaux%20et%20du%20d%C3%A9partement%20de%20la%20Gironde%20%20almanach%20des%2025000%20adresses%22%29%20and%20arkPress%20all%20%22cb32698045f_date%22&rk=21459;2). C'est, pour simplifier, l'√©quivalent des "pages jaunes" actuelles.

**Table A : extraits des "Fournisseurs de Chapellerie", 1855**
 | Nom               | Adresse                            |
 | ----------------- | ---------------------------------- |
 | Duch√™ne et Ce     | r. de la Bourse, 15                |
 | Marcon (S.) et Ce | rue du Parlement-Ste-Catherine, 30 |
 | Teindas (H.)      | r. St-Remi, 32                     |
 | Vallet (V.)       | pl. du Parlement, 8                |

**Table B : extraits des "Fournisseurs de Chapellerie", 1856**
| Nom               | Adresse                            |
| ----------------- | ---------------------------------- |
| Charrier (Ve)     | r. Notre-Dame, 74                  |
| Marcon (S.) et Ce | rue du Parlement-Ste-Catherine, 30 |
| Teindas (H.)      | r. St-Remi, 32                     |
| Vallet (V.)       | r. du Portail, 12                  |

> [!IMPORTANT]
> **üß© - QUESTION 1 - ‚≠ê**
>
> Prenez une minute pour r√©fl√©chir √† une strat√©gie permettant de d√©terminer si un enregistrement de la table $A$ a un correspondant dans la table $B$, et discutons-en tous ensemble !

Vous venez de concevoir un premier algorithme de couplage d'enregistrements ! üëè

### Posons les bases

Le *record linkage* ou *data matching* , en fran√ßais "couplage d'enregistrements", d√©signe un ensemble de techniques servant √† reconna√Ætre, dans deux bases de donn√©es, les **enregistrements** qui correspondent √† la m√™me **entit√©**, qu'il s'agisse de personnes, d'objets, d‚Äô√©v√©nements, etc.
Formalis√© dans le champ des technologies de l'information,  le couplage d'enregistrement est un classique du traitement des donn√©es en sciences sociales.
Un cas typique en histoire consiste √† relier des ensembles de donn√©es extraites dans des sources d'archives pour identifier, par exemple, les r√©f√©rences aux m√™mes entit√©s du monde r√©el, qu'il s'agisse de personnes, de lieux, etc.

Par souci de simplicit√©, on consid√®re uniquement la situation o√π les deux sources de donn√©es √† combiner sont des **tables**.
Une table est compos√©es de lignes appel√©es **enregistrements**, et de colonnes appell√©s **champs**.

Pour coupler les enregistrements de deux tables, on d√©cide d'un sous-ensemble de champs communs aux deux sources qui, ensemble, forment **l'identifiant unique** de chaque enregistrement. Dans l'exemple pr√©c√©dent, les **champs identifiants**`Nom` et `Adresse` forment ensemble l'identifiant unique des commerces. : si un enregistrement de $A$ et un enregistrement de $B$ ont les m√™mes valeurs de `Nom` et `Adresse` alors ils sont consid√©r√©s comme correspondants.

Le principe du couplage consiste donc √† cr√©er des liens entre enregistrements issus de deux tables et de tester si leurs identifiants correspondent. Lorsque c'est le cas on dit qu'il y a **accord** des deux enregistrements, ou plus simplement qu'il y a **match** (et **non-match** dans le cas inverse).

Le couplage d'enregistrement est un **processus**, automatisable √† l'aide d'un algorithme. Il en existe un grand nombre, mais ils se rangent dans seulement deux cat√©gories :

- le couplage **d√©terministe** o√π l'on applique des r√®gles de correspondance binaires (oui/non) sur les **champs identifiants** de deux enregistrements pour prendre une d√©cision binaire "tout ou rien" ;
- le couplage **probabiliste** qui utilise un mod√®le math√©matique pour associer une probabilit√©  de *match* entre deux enregistrements, puis prendre une d√©cision finale en consid√©rant les *matches* probables.

Les m√©thodes d√©terministes sont simples, mais elles ont tendance √† cr√©er de  nombreux faux n√©gatifs (on rate des couplages) lorsque les donn√©es sont imparfaites, bruit√©es ou incompl√®tes.
Les m√©thodes probabilistes tentent de surmonter ce probl√®me en associant un nombre r√©el aux possibles couplages, permettant une prise d√©cision plus fine et moins sensible aux imperfections des donn√©es.
Aujourd'hui, cette t√¢che est √©galement souvent r√©alis√©e avec des m√©thodes par apprentissage, "classique" (comme [SVM](https://fr.wikipedia.org/wiki/Machine_%C3%A0_vecteurs_de_support)),  voire par r√©seaux de neurones profonds.

Voil√† pour les grandes lignes,  place  √† l'exp√©rimentation pour mieux comprendre ! üë©‚Äçüíª

## B/  Couplage d√©terministe exact

√Ä partir de la fin du XVIIIe si√®cle et jusqu'au XXe si√®cle les **annuaires du commerce** fleurissent √† Paris . Ces ouvrages compilent, entre autres, les commer√ßants, notables et institutions urbaines dans de grandes listes imprim√©es souvent annuellement. Ce sont, en quelques sortes, les "pages jaunes" de l'√©poque.

Voici deux extraits d'annuaires  de Paris, publi√©s par l'imprimeur Didot-Bottin en 1842 et 1843.

![alignement_annuaires](https://hackmd.io/_uploads/ryRf3PLtke.jpg)

√Ä l'occasion du projet de recherche SODUCO, le contenu de ces annuaires a √©t√© extrait et transform√© en bases de donn√©es num√©riques s√©rielles.
Les donn√©es sont organis√©es en grands tableaux, un par annuaire, o√π chaque entr√©e de l'annuaire est un enregistrement contenant 3 champs :

- le **nom** (PER) de la personne/institution/commerce ;
- son **activit√©**, commerciale ou non (ACT) ;
- son **adresse** dans la ville, g√©n√©ralement au num√©ro (LOC).

On peut d√©j√† faire beaucoup avec de telles donn√©es, mais on a √©videmment tr√®s envie de pouvoir suivre un commerce ou une cat√©gorie professionnelle ou  au fil du temps, √† travers les annuaires trait√©s.

Voici un cas typique de couplage : il faut identifier les occurrences multiples du m√™me commerce dans plusieurs bases de donn√©es !

### Impl√©mentation na√Øve

Dans l'exemple pr√©c√©dent, on comprend imm√©diatement que M. Duchesne est actif les deux ann√©es. Il est √©vident qu'il s'agit de la m√™me personne car les champs PER, ACT et LOC sont identiques.

Ce couplage **exact** est le plus simple : il y a *match* si les champs identifiants (ici PER, ACT et LOC) sont exactement √©gaux.

| √âdition | PER      | ACT             | LOC        |
| ------- | -------- | --------------- | ---------- |
| 1842    | Duchesne | peintre-vitrier | Amboise, 9 |

| √âdition | PER      | ACT             | LOC        |
| ------- | -------- | --------------- | ---------- |
| 1843    | Duchesne | peintre-vitrier | Amboise, 9 |

> [!IMPORTANT]
> **üß© - QUESTION 2 - ‚≠ê‚≠ê**
>
> Impl√©mentez en Python cette premi√®re m√©thode de couplage exact entre deux enregistrements, repr√©sent√©s par des listes de cha√Ænes de caract√®res.
> Compl√©tez la fonction `calculer_score_exact` qui doit comparer les champs des enregistrements deux √† deux et retourner un nombre entier :
>
> - 1 si tous les champs sont deux √† deux √©gaux ;
> - 0 si au moins une paire de champs ne sont pas √©gaux.

> [!TIP] 
> **üß™ Sortie attendue** 
> ```raw
> ‚úÖ MATCH  :: ('Duchesne', 'Duchesne') ‚Ä¢ ('peintre-vitrier', 'peintre-vitrier') ‚Ä¢ ('Amboise, 9', 'Amboise, 9')
> ```

> [!NOTE] 
> **üìù √Ä retenir.**
> Coupler deux enregistrements qui repr√©sentent la m√™me entit√© du monde r√©el dans des sources de donn√©es diff√©rentes revient √† v√©rifier que les champs qui permettent de l'identifier de mani√®re **unique** sont les m√™mes. Ici, on a consid√©r√© que deux enregistrements d'annuaires concernent la m√™me personne si ils ont le m√™me nom (PER), la m√™me activit√© (ACT) et la m√™me adresse (LOC).

### Normaliser pour mieux comparer

En r√©alit√©, les donn√©es sont rarement imm√©diatement comparables. C'est d'autant plus vrai lorsqu'elles sont produites par extraction automatique, comme l'OCR, o√π les erreurs de reconnaissance peuvent √™tre nombreuses. Cela peut √™tre d√ª √† la qualit√© des num√©risations, aux graphies utilis√©es, √† l'√©tat de conservation des documents, etc.

L'exemple pr√©c√©dent √©tait corrig√© √† la main. Voici en r√©alit√© ce qui a √©t√© extrait par OCR des annuaires.

| √âdition | PER        | ACT             | LOC       |
| ------- | ---------- | --------------- | --------- |
| 1842    | duchesne,, | peintre v√étrier | amboise 9 |

| √âdition | PER      | ACT              | LOC         |
| ------- | -------- | ---------------- | ----------- |
| 1843    | DUch√´sne | Peintre -Vitrier | Amboise, 9. |

En l'√©tat, il est clair que la fonction`calculer_score_exact`ne va pas identifier de *match* entre ces deux enregistrements.

On a donc souvent besoin d'appliquer des **pr√©-traitements** pour **normaliser** les valeurs et qu'elles puissent √™tre compar√©es.

> [!IMPORTANT]
> **üß© - QUESTION 3 - ‚≠ê‚≠ê**
>
> Quelles transformations doit on appliquer aux cha√Ænes de caract√®res pour les **normaliser** et qu'elles soient de nouveau comparables avec `calculer_score_exact` ? Impl√©mentez ces transformations en compl√©tant la fonction `normaliser_champ`, puis testez-la avec les enregistrements ci-dessous.

> [!TIP] 
> **üß™ Sortie attendue**
> ```raw
>‚úÖ MATCH  :: ('duchesne,,', 'DUch√´sne') ‚Ä¢ ('peintre v√étrier', 'Peintre -Vitrier') ‚Ä¢ ('amboise 9', 'Amboise, 9.')
> ```


> [!NOTE]
> **üìù √Ä retenir.**
> Les donn√©es r√©elles sont rarement exemptes d'erreurs. C'est encore plus le cas de textes extraits automatiquement par OCR. Or, cela g√™ne fortement le couplage. Il est donc int√©ressant de faire pr√©c√©der le couplage lui-m√™me par des pr√©traitements pour "nettoyer" les enregistrements √† coupler.

## C/  Couplage d√©terministe "approximatif"

En r√©alit√©, les imperfections et erreurs qui affectent les donn√©es peuvent √™tre bien plus grandes. Pour nos annuaires, cela peut venir entre autres :

- d'erreurs de l'OCR : lettres mal reconnues, doubl√©es ou manquantes ;
- des  v√©ritables diff√©rences de graphie, typiques des documents historiques (ex. `Martyrs` et `Martirs`), des abr√©viations, etc.

Voici des extraits particuli√®rement bruit√©s d'enregistrements trouv√©s dans les annuaires :

| √âdition | PER                             | ACT                           | LOC        |
| ------- | ------------------------------- | ----------------------------- | ---------- |
| 1842    | lacrox (paul, (bibliophile iaco | membre du coniite des chartes | martirs 4I |

| √âdition | PER                              | ACT                        | LOC         |
| ------- | -------------------------------- | -------------------------- | ----------- |
| 1843    | Lacroix Paul. (Bibliophile jacob | membre du com. des chartes | Martyrs, 47 |

Il est clair que normaliser ne suffira pas : il y a plusieurs erreurs de reconnaissance OCR, des caract√®res manquent, etc.

On pourrait adapter la fonction `normaliser_champ`, mais cela signifie qu'il faudrait pr√©voir en avance tous les cas d'erreurs...

Un mani√®re de surmonter ce probl√®me consiste √† ne plus baser le couplage sur l'√©galit√© stricte de deux enregistrements,  mais √† plut√¥t mesurer un **score de similarit√©** entre eux.
Ce score est un nombre r√©el, par exemple entre 0.0 et 1.0. Un score de 0.0 signifie que les deux enregistrements sont tr√®s diff√©rents, et de 1.0 qu'ils sont tr√®s similaires (typiquement, √©gaux).

L'id√©e est donc de calculer un score de similarit√© pour chaque champ et de les agr√©ger pour obtenir un score de similarit√© global entre deux enregistrements.
Enfin, on d√©cide s'il y a *match* ou non en fixant un **seuil** : une similarit√© sup√©rieure √† ce seuil est un *match*.

Tr√®s bien mais...comment le mesure-t-on, ce score de similarit√© ?! ü§î

### Distance d'√©dition

 Est-ce-que `lacrox` est plus ou moins similaire √† `Lacroix`que `Lacroi` ? Quel score attribuer √† ces comparaisons ?

Une mani√®re simple de s'y prendre consiste √† mesurer une **distance d'√©dition** entre deux cha√Ænes de caract√®res, c'est √† dire le **nombre minimal de modifications** √† appliquer pour transformer une cha√Æne en l'autre. Ainsi, plus la distance d'√©dition est petite, plus les cha√Ænes se "ressemblent" !

Consid√©rons les r√®gles de modication suivantes :

1. Ajouter un caract√®re, ex. `Llcarox` -> `Llcaroix`.
2. Supprimer un caract√®re, ex. `Llcaroix` -> `Lcaroix`.
3. Substituer deux caract√®res, ex. `Lcaroix` -> `Lacroix`

La distance d'√©dtition entre`Llcarox` et `Lacroix` et de 3, puisqu'icil faut ajouter le caract√®re `i`, supprimer `l` et inverser `c`et `a` dans `Llcarox` pour obtenir `Lacroix`.

> [!IMPORTANT]
> **üß© - QUESTION 4 - ‚≠ê**
>
> Quelle est la distance d'√©dition entre les cha√Ænes de caract√®res `martirs 4I`et `Martyrs, 47` ? V√©rifiez √† l'aide de  l'outil en ligne [https://fr.planetcalc.com/1721](https://fr.planetcalc.com/1721) !

Vous connaissez peut-√™tre cette distance d'√©dition sous le nom de **[distance de Levenshtein](https://fr.wikipedia.org/wiki/Distance_de_Levenshtein)**, extr√™mement utilis√©e et impl√©ment√©e dans de nombreuses biblioth√®ques et *frameworks* logiciels.

Plusieurs biblioth√®ques Python impl√©mentent la distance de Levenshtein. Nous allons utiliser [NLTK](https://www.nltk.org/), une bo√Æte √† outil d√©di√©e au traitement automatique du langage naturel.  Dans NLTK, la distance de Levenshtein [`nltk.edit_distance`](https://tedboy.github.io/nlps/generated/generated/nltk.edit_distance.html) est disponibles dans le module `ntlk.metrics`.

> [!IMPORTANT]
> **üß© - QUESTION 5 -** 
>
> Installez NLTK  dans votre environnement Python courant avec `pip install` .
> Dans une console Python,  importez la m√©thode `edit_distance` du module `nltk.metrics` et v√©rifiez que la distance entre les cha√Ænes `martirs 4I`et `Martyrs, 47` soit celle attendue.

> [!TIP] 
> **üß™ Sortie attendue**
> ```raw
> nltk.edit_distance('martirs 4I, 'Martyrs, 47') = 4
> ```

### Similarit√© de cha√Ænes de caract√®res

La distance d'√©dition est une mesure absolue des diff√©rences entre deux cha√Ænes, elle ne mesure pas directement un **degr√©** de diff√©rence.
Autrement dit, une distance de 3 peut repr√©senter des √©carts tr√®s diff√©rents selon la longueur des cha√Ænes.
Ainsi, `edit_distance('martil', 'marcel')  == edit_distance('clo√Ætre St-Marcel', 'clo√Ætre Saint-Marcel' ) == 3`, pourtant cela repr√©sente dans un cas une diff√©rence de  50% et dans l'autre de seulement 15 √† 17% !

Pour rendre des distances d'√©ditions comparables il faut les **normaliser**, c'est-√†-dire les ramener dans un intervalle de valeurs fix√©, par exemple dans $[0,1]$.
Une m√©thode int√©ressante consiste √† normaliser la distance par la **longueur de la plus grande des deux cha√Ænes** :

``` math
d_{norm}(a,b) = \frac{edit\_distance(a,b)}{max(|a|,|b|)}
```

> [!IMPORTANT]
> **üß© - QUESTION 6 - ‚≠ê‚≠ê‚≠ê**
>
> Impl√©mentez la fonction `edit_distance_norm(str, str) -> float` qui renvoie la distance d'√©dition normalis√©e entre deux cha√Ænes de caract√®res. Testez avec l'exemple des questions 5/6. Comment s'interpr√™te le nombre obtenu ?

> [!TIP]
> **üß™ Sortie attendue**
>
> ```raw
> edit_distance_norm('martirs 4I, 'Martyrs, 47') = 0.36
> ```

> [!TIP]
> Si $a$ et $b$ toutes deux vides, on aura 0 au d√©nominateur ($max(|a|,|b|) = 0$), ce qui va provoquer une erreur `ZeroDivisionError`. En Python la fonction [`max()`](https://www.w3schools.com/python/ref_func_max.asp) accepte $n$ param√®tres, ce qui permet de se pr√©munir de l'erreur en passant en 3e param√®tre la constante `1`. Ainsi le d√©nominateur sera toujours sup√©rieur ou √©gal √† 1, sans provoquer d'effet de bord puisque cela impacte le d√©nominateur uniquement lorsque $a$ et $b$ sont vides et donc $d_{norm}(a,b) = \frac{0}{1} = 0$.

Enfin, on aimerait transformer cette distance normalis√©e en **similarit√©**, afin qu'elle soit facilement interpr√©table, c'est-√†-dire que $sim(a,b) = 1.0$ si $a = b$ et $sim(a,b) = 0.0$ si les cha√Ænes $a$ et $b$ n'ont aucun caract√®re commun.

> [!IMPORTANT]
> **üß© - QUESTION 7 - ‚≠ê**
>
> Impl√©mentez la fonction `similarit√©_str(str, str) -> float` qui appelle `edit_distance_norm()` et renvoie le score de similarit√© correspondant √† la distance calcul√©e entre deux cha√Ænes de caract√®res.

> [!TIP]
> **üß™ Sortie attendue**
> ```raw
> similarit√©_str('martirs 4I, 'Martyrs, 47') = 0.64
> ```

### Similarit√© entre enregistrements

On sait maintenant calculer un score de similarit√© entre deux cha√Ænes de caract√®res.

Un enregistrement √©tant compos√© de plusieurs champs, nous avons besoin d'une m√©thode pour calculer un score de similarit√© **entre enregistrements**, qui agr√®ge les scores des champs qui le composent.

Une solution consiste √† calculer la moyenne des scores de similarit√© entre champs.
Nous pourrions utiliser la moyenne arithm√©tique, mais elle a l'inconv√©nient de peu p√©naliser des champs tr√®s diff√©rents si d'autres champs sont proches.

Voici un exemple des simularit√©s entre deux enregistrements :

|                | PER      | ACT             | LOC        |
| -------------- | -------- | --------------- | ---------- |
| e1             | Duchesne | peintre-vitrier | Amboise, 9 |
| e2             | Morin    | peintre         | Amboise, 9 |
| **Similarit√©** | **0.13** | **0.47**        | **1.00**   |

La moyenne arithm√©tique des similarit√©s des champs PER, ACT et LOC est $\frac{0.13+0.47+1.00}{3} = 0.53$
Or on est plut√¥t certains qu'il ne s'agit pas du m√™me commerce car le nom est tr√®s diff√©rent, m√™me s'ils sont √† la m√™me adresse.
On pr√©f√©rerait **p√©naliser** plus fortement les cas o√π un champ est tr√®s diff√©rent, m√™me si les autres sont similaires.

Pour cela on peut lui pr√©f√©rer la **moyenne g√©om√©trique** des $n$ champs de deux enregistrements (ici on note $sim_{c_1}$ la similarit√© calcul√©e pour le premier champ, etc.) :

```math
\overline{sim} = \sqrt[n]{sim_{c_1} \times sim_{c_2} \times ... \times sim_{c_n}}
```

Dans l'exemple pr√©c√©dent, on a alors :

```math
\begin{equation*}
\begin{split}
\overline{sim}(e_1, e_2) & = \sqrt[3]{sim_{PER} \times sim_{ACT} \times sim_{LOC}}  \\
& = \sqrt[3]{0.13 \times 0.47 \times 1.0}  \\
& =  0.39
\end{split}
\end{equation*}
```

On voit que le faible score de similarit√© sur le champ PER a nettement p√©nalis√© la similarit√© agr√©g√©e.

> [!IMPORTANT]
> **üß© - QUESTION 8 - ‚≠ê‚≠ê‚≠ê**
>
> Impl√©mentez la fonction `calculer_score_approximatif(list[str], list[str]) -> float` qui calcule et renvoie  la **moyenne g√©om√©trique** des similarit√©s entre les champs de deux enregistrements. Reportez-vous aux commentaires dans `sequence_1.py`qui vous guideront pour coder la formule en Python.

> [!TIP]
> **üß™ Sortie attendue**
>
> ```raw
> Similarit√© entre les enregistrements lacroix_1841 et lacroix_1844 : 0.73
> ```

> [!NOTE]  
> **üöÄ Bonus:  pour aller plus loin.**
>
> On peut rendre param√©trable la p√©nalisation des faibles similarit√©s en appliquant une moyenne g√©om√©trique **pond√©r√©e** :
> $\overline{sim} = \sqrt[n]{sim_{c_1}^{\alpha} \times sim_{c_2}^{\alpha} \times ... \times sim_{c_n}^{\alpha}}$.  Le param√®tre $\alpha$ est un facteur de p√©nalisation : plus il est grand ( $\alpha > 1$), plus les valeurs proches de 0 p√©nalisent la valeur moyenne.

### Couplage approximatif

Vous voil√† maintenant capables de juger plus finement de la similarit√© entre deux enregistrements plut√¥t qu'avec un indicateur binaire, trop limit√©.

Reste tout de m√™me qu'in fine il faut **d√©cider** si, entre deux enregistrements, il y a *match*, ou non. On doit donc passer d'un score de similarit√© mesur√© par un r√©el entre 0 et 1,  √† une r√©ponse binaire *match* / *non match*.

Une mani√®re simple de s'y prendre consiste √† fixer un **seuil de couplage** : si la similarit√© est sup√©rieure √† ce seuil, alors il y a *match* !

> [!IMPORTANT]
> **üß© - QUESTION 9 - ‚≠ê‚≠ê‚≠ê**
>
> Cr√©ez la fonction `couplage_approximatif(list[str], list[str], float) -> (boolean, float)` qui :
>
> - prend en param√®tre 2 enregistrements et un seuil (nombre flottant)
> - normalise le seuil entre 0 et 1.
> - normalise les enregistrements √† l'aide de la fonction `normaliser_champ()` ;
> - calcule le score de couplage approximatif entre les enregistrements normalis√©s ;
> - d√©termine s'il y *match* √† l'aide du seuil et imprime "MATCH"  ou "NON MATCH" selon la d√©cision ;
> - renvoie un tuple contenant 2 valeurs : (1) un bool√©en donnant la d√©cision de couplage  et (2) le score de similarit√© entre les deux enregistrements.
>
> Testez votre m√©thode de couplage approximative sur les paires d'enregistrements suivants donn√©es dans `couplage.py` pour cette question.
> Testez diff√©rentes valeurs de seuil pour la fonction `couplage` : trouvez-vous facile de d√©terminer une valeur satisfaisante pour tous les cas ?

> [!TIP]
> **üß™ Sortie attendue**
>
> ```raw
> Couplage
> Param√®tres seuil= 0.5
> ‚úÖ MATCH (0.84) :: ('Lanet (Mme J.-A', 'Lanet (Mme)') ‚Ä¢ ('professeur d" "harmonie', 'professeur d" "harmonic') ‚Ä¢ ('Beaux-Arts 6', 'Beaux-Arts')
> ‚úÖ MATCH (1.00) :: ('Laplace et Dumont (Mlles', 'Laplace et Dumont (Mlles)') ‚Ä¢ ('institutrices', 'institutrices') ‚Ä¢ ('Lions-St-Paul 14', 'Lions-St-Paul 14')
> ‚úÖ MATCH (0.74) :: ('Regnault et vue Poupinel', 'Regnault et Vve Poupinel') ‚Ä¢ ('fab. douates, depƒõt', 'fab. douates, depet') ‚Ä¢ ('47 Cha-ronne', 'Charonne 47')
> ‚úÖ MATCH (0.50) :: ('Dast√©', 'Dast√© (J.)') ‚Ä¢ ('menuisier-√©b√®niste', 'menuisier') ‚Ä¢ ('Notre-Dame, 27', 'Regard, 5')
> ‚õî NON MATCH (0.47) :: ('Goix (Mme.)', 'Goix') ‚Ä¢ ('denteli√®re', 'dentelle et articles f√´m.') ‚Ä¢ ('c. de Tourny, 56', 'Tourny S6')
> ```

> [!NOTE]
> **üìù √Ä retenir.**
> Lorsque les enregistrements √† coupler contiennent des erreurs, ou de petites diff√©rences, le couplage exact est mis en √©chec et g√©n√®re des **faux n√©gatifs**, c'est-√†-dire des couplages qui n'ont pas √©t√© identifi√©s. Dans ce type de situation, on essaye plut√¥t de construire une mesure de la ressemblance entre deux enregistrements. Lorsque les champs sont des cha√Ænes de caract√®res, on utilise des mesures de similarit√© ou de distance entre mots pour cela. Il faut alors se doter d'une m√©thode de d√©cision pour choisir si une valeur de similarit√© / distance entre deux enregistrements signifie qu'ils sont coupl√©s, ou non.

## D/ Un processus  minimaliste mais complet de couplage d'enregistrements

Nous avons jusqu'ici :

- vu l'importance de pr√©-traiter les cha√Ænes de caract√®re pour faciliter leur comparaison ;
- test√© deux techniques de couplage d√©terministes, l'une exacte adapt√©e aux enregistrements sans erreurs, et l'autre approximative plus souple mais dont les r√©sultats sont moins facilement interpr√©tables ;
- test√© une m√©thode simple de classification d'une paire d'enregistrements en *match* ou *non-match* utilisant un seuil de similarit√©.

Les techniques impl√©ment√©es sont relativement simples et il existe des approches de couplage extr√™mement raffin√©es.
Toutefois, la structure d'une m√©thode de couplage d√©terministe entre deux tables $A$ et $B$ suit g√©n√©ralement quatre √©tapes :

1. **Pr√©-traitements** : Normaliser, √©liminer les enregistrements vides, etc.
2. **Comparaison** : Cr√©er toutes les paires possibles d'enregistrements de $A$ et $B$. Si chaque table contient 100 enregistrements, il faut cr√©er 10 000 paires !
3. **Classification** : D√©cider pour chaque paire si c'est un *match* ou un *non match*
4. **Post-traitements** : Supprimer toutes les paires *non match*, et renvoyer les *matches*.

> [!IMPORTANT]
> **üß© - QUESTION 10 - ‚≠ê‚≠ê‚≠ê‚≠ê**
>
> Impl√©mentez la fonction `couplage(list[list[str]], list[list[str]], float )-> list[list[]]` qui :
>
> - prend en param√®tre deux listes d'enregistrements A et B (deux listes de listes de `str`, donc.), et un seuil de couplage ;
> it√®re sur toutes les paires possibles d'enregistrements de A et B et applique `couplage_approximatif()` pour la classer la paire en *match* ou *non match*.
> - retourne l'ensemble des *match* sous la forme d'une liste de tuples `(i, j, score)` o√π :
>   - `i` et `j` sont les indices dans A et B respectivements des deux enregistrements coupl√©s
>   - `score` est le score de couplage;
>
> **Aidez-vous de la repr√©sentation algorithmique ci-dessous** pour impl√©menter la fonction !

```raw
____________________________________________________________
Algorithme 1 : Couplage de deux tables.
R√©sultat : La liste des couplages identifi√©s entre les deux tables.
Entr√©es : 
    - table_1 et table_2 : deux listes d'enregistrements (i.e. deux listes de listes de cha√Ænes de caract√®res).
    - seuil : le seuil de couplage, un nombre flottant entre 0 et 1. 
Sorties : une liste de couples (i, j, s) o√π i et j sont les indices des enregistrements dans leur tables respectives, et s le score de couplage.
____________________________________________________________

Initialiser une liste vide 'liste_couplages'.


POUR chaque enregistrement e1 dans table_1
    POUR chaque enregistrement e2 dans table_2
        Calculer le score de couplage approximatif entre e1 et e2 (normalis√©s !)
        SI c'est un *match* ALORS
            Cr√©er le couplage (i, j, s) avec :
                - i l'indice de e1 dans table_1, 
                - j l'indice de e2 dans table_2
                - s le score de couplage.
            Ajouter ce couplage √† 'liste_couplages'
        SINON
            continuer
        FIN SI
    FIN POUR
FIN POUR

RETOURNER 'liste_couplages'
```

Testez la m√©thode de couplage avec les deux listes d'enregistrements  donn√©es dans pour cette question`couplage.py`.

> [!TIP]
> **üß™ Sortie attendue**
>
> ```raw
> Couplage
> Param√®tres seuil= 0.3 alpha= 1.0
>table_1[0] & table_2[0] ‚á® ‚úÖ MATCH (0.50) :: ('Dast√©', 'Dast√© (J.)') ‚Ä¢ ('menuisier-√©b√®niste', 'menuisier') ‚Ä¢ ('Notre-Dame, 27', 'Regard, 5')
>table_1[2] & table_2[1] ‚á® ‚úÖ MATCH (0.84) :: ('Lanet (Mme J.-A', 'Lanet (Mme)') ‚Ä¢ ('professeur d" "harmonie', 'professeur d" "harmonic') ‚Ä¢ ('Beaux-Arts 6', 'Beaux-Arts')
>table_1[3] & table_2[2] ‚á® ‚úÖ MATCH (1.00) :: ('Laplace et Dumont (Mlles', 'Laplace et Dumont (Mlles)') ‚Ä¢ ('institutrices', 'institutrices') ‚Ä¢ ('Lions-St-Paul 14', 'Lions-St-Paul 14')
>table_1[4] & table_2[3] ‚á® ‚úÖ MATCH (0.74) :: ('Regnault et vue Poupinel', 'Regnault et Vve Poupinel') ‚Ä¢ ('fab. douates, depƒõt', 'fab. douates, depet') ‚Ä¢ ('47 Cha-ronne', 'Charonne 47')
>
> [üß™ Bonus si tabulate est install√© !]
>+--------------------------+-------------------------+------------------+---------+---------+---------------------------+-------------------------+-------------------+
>| 1.PER                    | 1.ACT                   | 1.LOC            | Match    |   Score | 2.PER                     | 2.ACT                   | 2.LOC             |
>+==========================+=========================+==================+=========+=========+===========================+=========================+===================+
>| Dast√©                    | menuisier-√©b√®niste      | Notre-Dame, 27   | ‚úÖ       |    0.50 | Dast√© (J.)                | menuisier               | Regard, 5         |
>| Loze (Jean)              | potier d'etain          | Greneta l2       | ‚õî       |         |                           |                         |                   |
>| Lanet (Mme J.-A          | professeur d" "harmonie | Beaux-Arts 6     | ‚úÖ       |    0.84 | Lanet (Mme)               | professeur d" "harmonic | Beaux-Arts        |
>| Laplace et Dumont (Mlles | institutrices           | Lions-St-Paul 14 | ‚úÖ       |    1.00 | Laplace et Dumont (Mlles) | institutrices           | Lions-St-Paul 14  |
>| Regnault et vue Poupinel | fab. douates, depƒõt     | 47 Cha-ronne     | ‚úÖ       |    0.74 | Regnault et Vve Poupinel  | fab. douates, depet     | Charonne 47       |
>|                          |                         |                  | ‚õî       |         | Weill (S.) jeune          | n√©gociant               | St.-Dominique, 18 |
>+--------------------------+-------------------------+------------------+---------+---------+---------------------------+-------------------------+-------------------+
> ```

## Ouf, c'est fini ! üèÅ

C'est tout pour cette fois, vous voici arriv√©(e)s au bout, f√©licitations ! üéâüéâ

Dans la prochaine s√©quence, nous apprendrons √† transformer la m√©thode de couplage impl√©ment√©e en un outil **en ligne de commande** r√©utilisable !
